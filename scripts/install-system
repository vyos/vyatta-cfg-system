#!/bin/bash
#
# Module: install-system
# 
# **** License ****
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# This code was originally developed by Vyatta, Inc.
# Portions created by Vyatta are Copyright (C) 2006, 2007 Vyatta, Inc.
# All Rights Reserved.
# 
# Author: Robert Bays
# Date: 2006
# Description:
# 
# **** End License ****
#
# Vyatta system installer script.
#

if [ `whoami` != 'root' ] ; then
    echo "This script must be run with root privileges."
    exit 1
fi

# If you set VYATTA_AUTO_INSTALL I will try to do an automated install for you

if [ -e /etc/default/vyatta ] ; then
    . /etc/default/vyatta
fi

# get system manufactuer, Xen needs special treatment
MANUF=`/usr/sbin/dmidecode -s system-manufacturer`

: ${vyatta_prefix:=/opt/vyatta}
: ${vyatta_exec_prefix:=$vyatta_prefix}
: ${vyatta_bindir:=${vyatta_exec_prefix}/bin}
: ${vyatta_sbindir:=${vyatta_exec_prefix}/sbin}
: ${vyatta_sysconfdir:=${vyatta_prefix}/etc}

ofrconfdir=${vyatta_sysconfdir}/config
rootfsdir=/mnt/rootfs

# By default this is not a union install
# UNION=false

# install log file name
INSTALL_LOG=/tmp/install-$$.log
# Absolute minimum root partition size in MB.  Below this, we won't let
# you install.
ROOT_MIN=1000

# the base install drive e.g. sda
if [ -n "$INSTALL_DRIVE" ]; then
  INSTALL_DRIVE=""
fi
# the install partition e.g. sda1
if [ -n "$ROOT_PARTITION" ]; then
  ROOT_PARTITION=""
fi
# the config partition e.g. sda2
if [ -n "$CONFIG_PARTITION" ]; then
  CONFIG_PARTITION=""
fi
# the size of the root partition
if [ -n "$ROOT_PARTITION_SIZE" ]; then
  ROOT_PARTITION_SIZE=""
fi
# global holding variable used in the select_partition sub
PARTITION=''

# default file system type
if [ "$MANUF" = "Xen" ]; then
  ROOT_FSTYPE="ext3"
else
  ROOT_FSTYPE="ext4"
fi

# start of root partition (64 sectors == 32K bytes)
ROOT_OFFSET="64S"

# Process ID of this script for the lame marketing spinner
SPID=$$

# Grub options
GRUB_OPTIONS="quiet"

# Enable Vesa framebuffer mode (comment out to disable)
VGA_LOGO="vga=0x314"		# 800 x 600 (16bit colors)

# trap signals so we can kill runaway progress indicators
trap 'progress_indicator stop; exit 1' 1
trap 'progress_indicator stop; exit 1' 2

# turn off any mounted swap partitions
turnoffswap () {
  if [ -f "/proc/swaps" ]; then
    myresponse=$(cat /proc/swaps)
    if [ -n "$myresponse" ]; then
      echo "turning off swaps..." >> $INSTALL_LOG
      swapoff -a
    fi
  fi
}

tolower () {
    echo "$*" | tr '[:upper:]' '[:lower:]'
}

# Validates a user response.  Returns the response if valid.
# Returns the default is the user just hits enter.  
# Returns nothing if not valid.  Default parameter is $1.
# Options are in $2.  If options are defined return must be a member
# of the enum. 
get_response () {
  local ldefault=$(tolower "$1")
  local loptions=$(tolower "$2")

  # get the response from the user
  read myresponse
  myresponse=$(tolower "$myresponse")

  # Check to see if the user accepts the default
  if [ -z "$myresponse" ]; then
    echo -n $ldefault
  # if we are passing in options to check, make sure response is a valid option
  elif [ -n "$loptions" ]; then
    for token in $loptions
      do
        if [ "$token" == "$myresponse" ]; then
          echo -n "$myresponse"
          return 0
        fi
      done
    return 1
  else
    echo -n "$myresponse"
  fi

  return 0
}

# Return the size of the drive in MB
get_drive_size () {
  local ldrive=$1

  # Get size of disk in 1k blocks
  local blocks=$(sfdisk -s /dev/$ldrive)

  # Translate to Megabytes (SI units)
  local bytes=$(($blocks * 1024))
  local lsize=$(($bytes / 1000000))

  echo $lsize
}

# Probe hardrives not shown in /proc/partitions by default
probe_drives () {
  # Find drives that may not be in /proc/partitions since not mounted
  drive=$(ls /sys/block  | grep '[hsv]d.')

  # now exclude all drives that are read-only
  for drive in $drive
  do
      if [ $(cat /sys/block/$drive/ro) -ne 0 ]
      then
	  output=$(mount | grep $drive)
	  if [ -z "$output" ]; then
              output=$(parted -s /dev/$drive p)
	  fi
      fi
  done
}


warn_of_dire_consequences () {
  # Give the user a requisite warning that we are about to nuke their drive
  response=''
  while [ -z "$response" ]
  do
    echo "This will destroy all data on /dev/$INSTALL_DRIVE."
    echo -n "Continue? (Yes/No) [No]: "
    response=$(get_response "No" "Yes No Y N")

    if [ "$response" == "no" ] || [ "$response" == "n" ]; then
      echo "Ok then.  Exiting..."
      exit 1
    fi
  done
}



check_for_old_raid () {
    # First, trigger construction of previously configured RAID groups
    echo -n "Looking for pre-existing RAID groups..."
    raid_config=`mdadm --examine --scan`
    if [ -z "$raid_config" ]; then
	echo "none found."
	return
    fi

    echo "found some."
    echo "Trying to configure pre-existing RAID groups..."
    mdadm --assemble --scan --auto=yes --symlink=no

    # Identify physical drives
    raid_drives=$(cat /proc/partitions | awk '{ if ($4!="name") { print $4 } }' | grep "md" | egrep -v "^$")

    if [ -z "$raid_drives" ]; then
	echo "Unable to configure any RAID groups."
	return
    fi

    numraids=`echo $raid_drives | wc -w`

    if [ $numraids -eq 1 ]; then
	echo "The following RAID group is now configured:"
    else
	echo "The following RAID groups are now configured:"
    fi

    for drive in $raid_drives
    do
	cat /proc/mdstat | grep --after-context 2 ^$drive | sed -e 's/^/\t/'
    done

    if [ $numraids -eq 1 ]; then
	echo -n "Would you like to use this one? (Yes/No) [Yes]:"
    else
	echo -n "Would you like to use one of these? (Yes/No) [Yes]:"
    fi

    response=$(get_response "Yes" "Yes No Y N")
    if [ "$response" == "no" ] || [ "$response" == "n" ]; then
	echo
	echo "Ok.  Not using existing RAID groups."
	echo

	# pick the first RAID group to be broken
	raid_drive=$(echo $raid_drives | /usr/bin/awk '{ print $1 }')

	echo "Would you like to break RAID group $raid_drive so that its"
	echo "members can be re-used for a new installation, understanding"
	echo -n "that doing so will destroy all data on it? (Yes/No) [No]:"
	destroy_raid=$(get_response "No" "Yes No Y N")
	echo

	if [ "${destroy_raid:0:1}" = "y" ]; then
	    echo "OK.  Breaking the RAID group $raid_drive."
	    
	    members=`ls /sys/block/$raid_drive/slaves`

	    echo "First, stopping all existing RAID groups:"
	    mdadm --stop --scan

	    for member in $members ; do
		drive=${member:0:3}
		part=${member:3:1}
		echo "Re-setting partition ID for RAID group $raid_drive member /dev/${member}:"
		sfdisk --change-id /dev/$drive $part 0x83
		echo "Clearing RAID superblock from RAID group $raid_drive member /dev/${member}."
		mdadm --zero-superblock /dev/$member
	    done
	else
	    echo "OK.  Stopping, but not breaking, existing RAID groups:"
	    mdadm --stop --scan
	fi

	echo
	return
    fi

    if [ $numraids -eq 1 ]; then
	INSTALL_DRIVE=$raid_drives
    else
	# take the first drive as the default
	INSTALL_DRIVE=$(echo $raid_drives | /usr/bin/awk '{ print $1 }')
    	echo -n "Which one would you like to use? ($raid_drives) [$INSTALL_DRIVE]: "
	INSTALL_DRIVE=$(get_response "$INSTALL_DRIVE" "$drives")
    fi

    echo "Using RAID partition $INSTALL_DRIVE"

    raid_degraded=`cat /sys/block/$INSTALL_DRIVE/md/degraded`
    raid_sync_action=`cat /sys/block/$INSTALL_DRIVE/md/sync_action`

    if [ "$raid_degraded" = "1" ]; then
	echo
	if [ "$raid_sync_action" = "recover" ]; then
	    echo "Error: This RAID set is degraded and is in the process of"
	    echo "rebuilding.  It is not safe to install onto it while the"
	    echo "rebuild is in progress. Please wait for the rebuild to"
	    echo "complete and then re-start the installation.  You may"
	    echo "monitor the progress of the RAID rebuild with the"
	    echo "command:"
	    echo
	    echo "    show raid $INSTALL_DRIVE"
	    echo
	    exit 1
	fi
	echo "Warning:  This RAID set is degraded, but is not in the"
	echo "process of rebuilding.  It is safe to perform the installation"
	echo "onto a degraded RAID set that is not in the process of"
	echo "rebuilding.  You may stop the installation now and rebuild the"
	echo "RAID set, or continue installing onto it.  If you continue"
	echo "installing, do not attempt to rebuild the RAID set until the"
	echo "installation has completed and you have rebooted the system."
	echo
    fi

    warn_of_dire_consequences

    ROOT_PARTITION=$INSTALL_DRIVE

    # make sure we aren't working on a mounted part
    unmount "$INSTALL_DRIVE"

    # check for an old config on the partition
    check_config_partition "$ROOT_PARTITION"

    # create the filesystem on the part
    make_filesystem "$ROOT_PARTITION"

    INSTALL_METHOD=RAID
}

check_for_new_raid () {
    # Identify physical drives
    drives=$(cat /proc/partitions | awk '{ if ($4!="name") { print $4 } }' | egrep -v "[0-9]$" | egrep -v "^$")

    numdrives=`echo $drives | wc -w`

    # Need at least two drives for RAID-1.  We don't yet have the code
    # to handle selection of two from a set of 3 or more, so for now, we
    # only support two drives.
    #
    if [ $numdrives -ne 2 ]; then
	return
    fi

    drive1=`echo $drives | awk '{ print $1 }'`
    drive2=`echo $drives | awk '{ print $2 }'`

    drivesize1=$(get_drive_size $drive1)
    drivesize2=$(get_drive_size $drive2)

    # Both drives must have enough space to hold our minimum root filesystem
    #
    if [ $drivesize1 -lt $ROOT_MIN -o $drivesize2 -lt $ROOT_MIN ]; then
	return
    fi


    echo "You have two disk drives:"
    echo -e "\t$drive1 \t$drivesize1 MB"
    echo -e "\t$drive2 \t$drivesize2 MB"

    echo -n "Would you like to configure RAID-1 mirroring on them? (Yes/No) [Yes]:"
    response=$(get_response "Yes" "Yes No Y N")
    if [ "$response" == "no" ] || [ "$response" == "n" ]; then
	echo "Ok.  Not configuring RAID-1."
	return
    fi

    if [ $drivesize1 -ne $drivesize2 ]; then
	echo "Since the disks are not the same size, we will use the smaller"
	echo "of the two sizes in configuring the RAID-1 set.  This will"
	echo "waste some space on the larger drive."
	echo ""
    fi

    # Configure RAID-1
    echo "This process will erase all data on both drives."
    echo -n "Are you sure you want to do this? (Yes/No) [No]: "
    response=$(get_response "Yes" "Yes No Y N")
    if [ "$response" == "no" ] || [ "$response" == "n" ]; then
	echo "Ok.  Not configuring RAID-1."
	return
    fi
    
    for drive in $drives
    do
	echo "Deleting old partitions on drive $drive"
	# remove any existing partitions on that drive
	delete_partitions "$drive"
    done

    # Need to leave space on both disks between the MBR and the start
    # of the first partition for grub.  Grub needs to embed a large
    # boot image there when booting off RAID devices.
    #
    # Partition creation variables are in units of megabytes.
    part_start_offset=2
    part_diag_size=60

    if [ $drivesize1 -lt $drivesize2 ]; then
	root_size=$drivesize1
    else
	root_size=$drivesize2
    fi

    let min_size_with_diag=${MIN_ROOT}+${part_diag_size}
    if [ $root_size -ge $min_size_with_diag ]; then
	echo "Would you like me to create a $part_diag_size MB partition for diagnostics?"
	echo -n "(Yes/No) [No]: "
	diag_response=$(get_response "No" "Yes No Y N")
	if [ "$diag_response" == "yes" ] || [ "$diag_response" == "y" ]; then
	    for drive in $drives
	    do
		echo "Creating diag partition on drive $drive"
		create_partitions "$drive" $part_diag_size $part_start_offset "no"
		sfdisk --change-id /dev/$drive 1 0x6
	    done
	    data_dev=2
	    let part_start_offset+=$part_diag_size
	else
	    data_dev=1
	fi
    fi

    let root_size-=$part_start_offset

    for drive in $drives
    do
	echo "Creating data partition: /dev/${drive}${data_dev}"
	create_partitions "$drive" $root_size $part_start_offset "no"
	sfdisk --change-id /dev/$drive $data_dev 0xfd
	# mark data partition as bootable
	echo "Marking /dev/$drive partition $data_dev bootable" >> $INSTALL_LOG
	parted -s /dev/$drive set $data_dev boot on >> $INSTALL_LOG 2>&1
    done

    # Must give partition device time to settle
    sleep 5
    echo

    for drive in $drives
    do
	echo "Erasing any previous RAID metadata that may exist on /dev/${drive}${data_dev}"
	mdadm --zero-superblock /dev/${drive}${data_dev}
    done

    echo "Creating RAID-1 group on partitions: /dev/${drive1}${data_dev} /dev/${drive2}${data_dev}"

    raid_dev=md0
    mdadm --create /dev/$raid_dev --level=1 --raid-disks=2 --metadata=0.90 /dev/${drive1}${data_dev} /dev/${drive2}${data_dev}

    if [ $? = 0 -a -e /dev/$raid_dev ]; then
	echo "RAID-1 group created successfully:"
	cat /proc/mdstat | grep --after-context 2 ^$raid_dev | sed -e 's/^/\t/'
    else
	echo "Unable to create RAID-1 group!"
	return
    fi

    INSTALL_DRIVE=$raid_dev
    ROOT_PARTITION=$INSTALL_DRIVE

    # Give device time to settle...
    sleep 5

    # create the filesystem on the part
    make_filesystem "$ROOT_PARTITION"

    INSTALL_METHOD=RAID
}


# Takes an argument to display text before choice
# Sets INSTALL_DRIVE.  Note that select_drive should be wrapped 
# in the verification loop, not the included get_response.
select_drive () {
  # list the drives in /proc/partitions.  Remove partitions and empty lines.
  # the first grep pattern looks for devices named c0d0, hda, and sda.
  drives=$(cat /proc/partitions | \
           awk '{ if ($4!="name") { print $4 } }' | \
           egrep "c[0-9]d[0-9]$|[hsv]d[a-z]$" | \
           egrep -v "^$")

  # take the first drive as the default
  INSTALL_DRIVE=$(echo $drives | /usr/bin/awk '{ print $1 }')

  # Add the drive sizes to the display to help the user decide
  display=''
  for drive in $drives
  do
    size=$(get_drive_size $drive)
    display="$display $drive\t$size"MB"\n"
  done

  while true
  do
	# Display the drives and ask the user which one to install to
	echo -e "$display"
	echo
	echo -n "$1 [$INSTALL_DRIVE]:"
	response=$(get_response "$INSTALL_DRIVE" "$drives") && break
  done
  INSTALL_DRIVE="$response"

  echo
}

# Allow the user to select a partition to work with
# sets the global PARTITION
# $1 is the text to display before prompt
select_partition () {
  minsize=$1
  text=$2
  exclude=$3

  echo -n "Looking for appropriate partitions:  "
  progress_indicator start

  # initialize out global var.  using globals in this way is bad form.  I know.
  PARTITION=''

  # list only the partitions in /proc/partitions.
  parts=$(cat /proc/partitions | awk '{ if ($4!="name") { print $4 " "} }' | egrep "[0-9]" | egrep -v "loop" | tr -d '\n')

  # remove any partitions we have already previously used
  if [ -n "$exclude" ]; then
    for part in $parts; 
    do
      temp=$(echo $part | egrep -v $exclude)
      parts_temp="$parts_temp $temp"
    done
    parts=$parts_temp
  fi

  # Get the partition sizes for display
  # only show linux partitions that have sizes, i.e. remove loops
  display=''
  myparts=''
  for part in $parts
  do
    if [ ${part:0:2} = "md" ]; then
      parttype="RAID"
    else
      rootdev=$(echo $part | sed 's/[0-9]//g')
      parttype=$(fdisk -l /dev/$rootdev | grep $part | grep Linux)
    fi
    if [ -n "$parttype" ]; then
      lsize=$(get_drive_size $part)
      if [ "$lsize" -a $lsize -ge $minsize ]; then
        display="$display $part\t\t$lsize"MB"\n"
        myparts="$myparts $part"
      fi
    fi
  done

  progress_indicator stop
  echo "OK"

  if [ -n "$myparts" ]; then
    lpartition=''
    while [ -z "$lpartition" ]
    do
      # take the first partition as the default
      lpartition=$(echo $myparts | /usr/bin/awk '{ print $1 }')

      echo "I found the following partitions suitable for the Vyatta image:"
      echo -e "Partition\tSize"
      echo -e "$display"
      echo
      echo -n "$text [$lpartition]: "

      lpartition=$(get_response "$lpartition" "$myparts")
      echo
    done
  else
    echo "No suitable partition sizes found.  Exiting..."  | tee $INSTALL_LOG
    exit 1
  fi
  PARTITION=$lpartition
}

rename_old_config() {
  files=$(find /mnt/config -mindepth 1 -type f | grep -v pre-glendale)
  for f in $files; do
    if grep -q '/\*XORP Configuration File, v1.0\*/' $f >&/dev/null; then
      CURTIME=$(date +%F-%H%M%S)
      mv $f $f.pre-glendale.$CURTIME
    fi
  done
}

# copy old config file from /mnt/tmp
save_old_config() {
      local response=''
      while [ -z "$response" ]
      do
        echo "/dev/$lpart has an old configuration directory!"
        echo -ne "Would you like me to save the data on it\nbefore I delete it? (Yes/No) [Yes]: "
        response=$(get_response "Yes" "Yes No Y N")
     done

     if [ "$response" == "yes" ] || [ "$response" == "y" ]; then
         mkdir -p /mnt/config
         if [ -d /mnt/tmp/opt/vyatta/etc/config ]; then
             output=$(cp -pR /mnt/tmp/opt/vyatta/etc/config/* /mnt/config)
         else
             output=$(cp -pR /mnt/tmp/* /mnt/config)
         fi
         if [ -n "$output" ]; then
             echo -e "Warning: error in copying the old config partition.\nSee $INSTALL_LOG for more details."
            echo -e "Warning: error in copying the old config partition.\ncp -pR /mnt/tmp/* /mnt/config\n$output\n" >> $INSTALL_LOG
         fi
         rename_old_config
     fi
}

save_old_keys() {
    local response=''

    while [ -z "$response" ]
    do
        echo "/dev/$lpart has SSH host keys"
        echo -ne "Would you like me to keep SSH keys on new install? (Yes/No) [Yes]: "
        response=$(get_response "Yes" "Yes No Y N")
    done

    if [ "$response" == "yes" ] || [ "$response" == "y" ]; then
        mkdir -p /mnt/ssh
	output=$(cp -p /mnt/tmp/etc/ssh/ssh_host_* /mnt/ssh)

        if [ -n "$output" ]; then
            echo -e "Warning: error in copying the old ssh keys."
	    echo -e "See $INSTALL_LOG for more details."
            echo "Warning: error in copying the old ssh keys." >> $INSTALL_LOG
	    echo "cp -pR /mnt/tmp/etc/ssh/ssh_host_* /mnt/ssh" >> $INSTALL_LOG
	    echo "$output\n">> $INSTALL_LOG
        fi
    fi
}

save_image_config() {
    image_name=$1

    # Cleanup from possible partial last run
    rm -fr /mnt/config
    mkdir /mnt/config

    output=$(cp -pR /mnt/tmp/boot/$image_name/live-rw/config/* /mnt/config)

    if [ -n "$output" ]; then
        echo -e "Warning: error in copying the old config partition.\nSee $INSTALL_LOG for more details."
        echo "Warning: error in copying the old config partition.\ncp -pR /mnt/tmp/* /mnt/config\n$output\n"
    fi
    rename_old_config
}

save_image_keys() {
    image_name=$1

    if [ ! -d /mnt/tmp/boot/$image_name/live-rw/etc/ssh ]; then
        echo "No SSH keys found on $image_name, so none can be saved."
        return;
    fi

    echo -n "Would you like to save SSH keys from $image_name too? (Yes/No) [Yes] "

    response=$(get_response "Yes" "Yes No Y N")
    if [ "$response" != "yes" ] && [ "$response" != "y" ]; then
        echo "OK. SSH keys not saved."
        return
    fi

    mkdir -p /mnt/ssh
    output=$(cp -p /mnt/tmp/boot/$image_name/live-rw/etc/ssh/ssh_host_* /mnt/ssh)

    if [ -n "$output" ]; then
        echo -e "Warning: error in copying the old ssh keys."
        echo -e "See $INSTALL_LOG for more details."
        echo "Warning: error in copying the old ssh keys." >> $INSTALL_LOG
        echo "cp -pR /mnt/tmp/etc/ssh/ssh_host_* /mnt/ssh" >> $INSTALL_LOG
        echo "$output\n">> $INSTALL_LOG
        return
    fi

    # reset modes on keys (should already be set)
    chmod 600 /mnt/ssh/*_key 2>&1
    chmod 644 /mnt/ssh/*.pub 2>&1

    echo "SSH keys have been saved."
}



## check_config_partition
# look to see if this partition contains a config file
# and back it up
check_config_partition() {
  lpart=$1
  copied=0

  # Cleanup from possible partial last run
  rm -fr /mnt/config

  # Look to see if this is a config partition
  mkdir -p /mnt/tmp
  output=$(mount -r /dev/$lpart /mnt/tmp 2>&1)
  if [ $? != 0 ]; then
    echo -e "Cannot mount /dev/$lpart"."\nmount /dev/$ldrive$part /mnt/tmp\nExiting..." >> $INSTALL_LOG
    echo "$output" >> $INSTALL_LOG
    return
  fi

  # Look to see if there is a config partition there
  if [ -f /mnt/tmp/opt/vyatta/etc/config/.vyatta_config ] ||
     [ -f /mnt/tmp/.vyatta_config ]; then
      save_old_config
      copied=1
  fi

  # Look to see if there are SSH host keys
  if [ -d /mnt/tmp/etc/ssh ];  then
      save_old_keys
      copied=1
  fi

  if [ $copied -eq 0 ]; then
      # Check for images
      images=()
      image_dirs=/mnt/tmp/boot/*

      for dir in $image_dirs; do
          if [ -f $dir/live-rw/config/.vyatta_config ]; then
              item=${dir##/mnt/tmp/boot/}
                  images=($item ${images[@]})
          fi
      done

      num_images=${#images[@]}

      if [ $num_images -gt 0 ]; then
          echo "I found the following installed system image(s) with config files on $part:"
          for (( i = 0; i < $num_images; i++ )); do
              echo "  $((i + 1)): ${images[$i]}"
          done
	  
          if [ $num_images -eq 1 ]; then
              echo -n "Would you like to save config information from it? (Yes/No) [Yes] "
          else
              echo -n "Would you like to save config information from one? (Yes/No) [Yes] "
          fi

          response=$(get_response "Yes" "Yes No Y N")
          if [ "$response" != "yes" ] && [ "$response" != "y" ]; then
              echo "OK.  Config information not saved."
	      umount /mnt/tmp
              return
          fi

          if [ $num_images -gt 1 ]; then
              image_index=-1
              while [ $image_index -lt 0 -o $image_index -ge $num_images ];  do
                  echo -n "Which image would you like to use? (1 .. $num_images): "
                  read num
                  image_index=$((num - 1))
              done
          else
              image_index=0
          fi

          image_name=${images[$image_index]}
          echo "Saving config information from image $image_name."
          save_image_config $image_name
          echo "Done."
          save_image_keys $image_name
      fi
  fi
  umount /mnt/tmp
}

# Delete all existing partitions for an automated install
# $1 is the drive to delete partitions from
delete_partitions () {
  ldrive=$1

  # get the partitions on the drive
  # in the first grep below we add the optional [p] in order to accomdate cciss drives
  partitions=$(cat /proc/partitions | grep $ldrive[p]*[0-9] | awk '{ print $4 }' | sed 's/\(.*\)\([0-9]$\)/\2/g' | grep -v "^$")

  # now for each part, blow it away
  for part in $partitions
  do
    # Look to see if this is a config partition
    check_config_partition "$ldrive$part"

    echo "Removing partition $part on /dev/$ldrive" >> $INSTALL_LOG
    output=$(parted -s /dev/$ldrive rm $part)
    status=$?
    if [ "$status" != 0 ]; then
      echo -e "Warning: cannot delete partition $part on $ldrive.\nPlease see $INSTALL_LOG for more details."
      echo -e "Warning: cannot delete partition $part on $ldrive.\nparted /dev/$ldrive rm $part\n$output" >> $INSTALL_LOG
    fi

    # We add a bogus sleep here because the loop needs to wait for udev
    sleep 5
  done
}

# make a filesystem on the drive
# $1 is the drive to format
make_filesystem () {
  ldrive=$1

  echo -n "Creating filesystem on /dev/$ldrive:  "
  echo "Creating filesystem on /dev/$ldrive..." >> $INSTALL_LOG

  progress_indicator start
  output=$(mkfs -t $ROOT_FSTYPE /dev/$ldrive 2>&1)
  status=$?
  if [ "$status" != 0 ]; then
    echo -e "Error: couldn't create the root filesystem.\nSee $INSTALL_LOG for further details.\nExiting..."
    echo -e "Error: couldn't create the root filesystem.\n/sbin/mke2fs -j /dev/$ldrive\n$output"
    exit 1
  fi
  progress_indicator stop
  echo "OK"
}

# create the root partition
# $1 is the install drive e.g. sda
# $2 is the partition size e.g. 512
# This will set the global ROOT_PARTITION
create_partitions() {
  ldrive=$1
  root_part_size=$2
  start_offset=$3
  initialize_fs=$4

  # Make sure there is enough space on drive
  size=$(get_drive_size "$ldrive") 
  if [ "$root_part_size" -gt "$size" ]; then
    echo "Error: $ldrive is only $size"MB" large.  Desired root is $root_part_size"
    exit 1
  fi

  # Make sure you can print disk info using parted
  parted --script /dev/$ldrive p >/dev/null 2>&1

  # If unable to read disk, it's likely it needs a disklabel
  if [ "$?" != "0" ]; then
    echo "Creating a new disklabel on $ldrive"
    echo "parted /dev/$ldrive mklabel msdos"
    output=$(parted -s /dev/$ldrive mklabel msdos)

    parted --script /dev/$ldrive p >/dev/null 2>&1
    if [ "$?" != "0" ]; then
      echo "Unable to read disk label.  Exiting."
      exit 1
    fi
  fi

  echo "Creating root partition on /dev/$ldrive" >> $INSTALL_LOG
  
  # make the root partition
  # align at optimal block boundary
  output=$(parted -s /dev/$ldrive mkpart primary $start_offset $root_part_size)
  status=$?
  if [ "$status" != 0 ]; then
    echo -e "Error creating primary partition on $ldrive.\nPlease see $INSTALL_LOG for more details.\nExiting..."
    echo -e "Error creating primary partition on $ldrive.\nparted /dev/$ldrive mkpart primary $start_offset $root_part_size\n$output" >> $INSTALL_LOG
    exit 1
  fi

  # set the partition number on the device.
  if [ -n "$( echo $ldrive | grep -E "cciss|ida" )" ]; then
    # if this is a cciss
    ROOT_PARTITION=$ldrive"p1"
  else
    # else... the rest of the world
    ROOT_PARTITION=$ldrive"1"
  fi
  # udev takes time to re-add the device file, so wait for it
  while [ ! -b "/dev/$ROOT_PARTITION" ] 
  do 
    sleep 1
  done

  if [ "$initialize_fs" = "yes" ]; then
    # make the root and config file systems.
    make_filesystem "$ROOT_PARTITION"
  fi
}

# Copy directory with pretty progress bar
copy_filesystem() {
    cp -r -v --preserve=all "$@" | awk '{
	++files
	if ((files % 100) == 0) {
	    percent = files / total_files * 100
	    printf "%3d%% [", percent
            for (i=0;i<percent; i+=2)
                printf "="
            printf ">"
	    for (;i<100;i+=2)
                printf " "
            printf "]\r"
	    fflush()
	}
     }' total_files=$(find "$@" | wc -l)
}

# Install the root filesystem
# $1 is the partition to install on
install_root_filesystem () {
  ldrive=$1
  version=`dpkg-query --showformat='${Version}' --show vyatta-version`

  dpkg="/usr/bin/dpkg --force-all --root=$rootfsdir"
  echo "Mounting /dev/$ldrive "
  echo "Mounting /dev/$ldrive..." >> $INSTALL_LOG

  # make the mount point
  output=$(/bin/mkdir -p $rootfsdir)

  # mount the partition
  output=$(mount /dev/$ldrive $rootfsdir)
  status=$?
  
  if [ "$status" != 0 ]; then
    echo -e "Error trying to mount the new root partition.\nPlease see $INSTALL_LOG for details.\nExiting..."
    echo -e "Error trying to mount the new root partition.\nmount /dev/$ldrive $rootfsdir\n$output" >> $INSTALL_LOG
    exit 1
  fi
  
  if [ -z "$UNION" ]; then
    echo "Copying system files to /dev/$ROOT_PARTITION: "
    # Mount the squashfs for copying
    output=$(mkdir -p /mnt/squashfs)
    if [ -f /live/image/live/filesystem.squashfs ]; then
      output=$(mount /live/image/live/filesystem.squashfs /mnt/squashfs -t squashfs -o loop)
      status=$?
    elif [ -f /live/image/boot/$version/$version.squashfs ]; then
      output=$(mount /live/image/boot/$version/$version.squashfs /mnt/squashfs -t squashfs -o loop)
      status=$?
    else
      echo -e "Error: Unable to find a squash image. To install natively\nthe install media must be a livecd or a union install.\nExiting...\n\n"
      echo -e "Error: Unable to find a squash image. To install natively\nthe install media must be a livecd or a union install.\nExiting...\n\n" >> $INSTALL_LOG
      exit 1
    fi
  
    if [ "$status" != 0 ]; then
      echo -e "Error trying to mount the squashfs.\nPlease see install log for more details.\nExiting..."
      echo -e "Error trying to mount the squashfs.\nmount /live/image/live/filesystem.squashfs /mnt/squashfs -t squashfs -o loop\n$output" >> $INSTALL_LOG
      exit 1
    fi

    echo "Copying /mnt/squashfs/* to $rootfsddir" >>$INSTALL_LOG
    copy_filesystem /mnt/squashfs/* $rootfsdir 2>>$INSTALL_LOG
    status=$?
    echo

    if [ "$status" != 0 ]; then
      echo -e "Error trying to copy the rootfs.\nPlease see install log for more details.\nExiting..."
      exit 1
    fi

    # unmount the squashfs.  No big deal if it fails.
    output=$(umount /mnt/squashfs)

    # create the fstab
    local rootdev="/dev/$ROOT_PARTITION";
    uuid=$(dumpe2fs -h $rootdev 2>/dev/null | awk '/^Filesystem UUID/ {print $3}')
    if [ -z "$uuid" ]
    then
        echo "Unable to read filesystem UUID.  Exiting."
        exit 1
    else
      if [ "$MANUF" = "Xen" ]; then
        #disable barriers explicitly (just incase)
        echo -e "UUID=$uuid\t/\t$ROOT_FSTYPE\tnoatime,nobarrier\t0 1" >> $rootfsdir/etc/fstab
      else
        echo -e "UUID=$uuid\t/\t$ROOT_FSTYPE\tnoatime\t0 1" >> $rootfsdir/etc/fstab
      fi
    fi

    #setup the hostname file
    cp /etc/hostname $rootfsdir/etc/
    cp /etc/hosts $rootfsdir/etc/

    progress_indicator stop
    echo "OK"
  else
    # UNION install
    mkdir -p $rootfsdir/boot/$version
    ## make dir for backing store
    mkdir -p $rootfsdir/boot/$version/live-rw
    if [ -f /live/image/live/filesystem.squashfs ]; then
      echo Copying squashfs image...
      cp /live/image/live/filesystem.squashfs $rootfsdir/boot/$version/$version.squashfs
      echo Copying kernel and initrd images...
      cp -a /boot/* $rootfsdir/boot/$version/
    else
      echo Copying image files...
      cp -ar /live/image/boot/$version $rootfsdir/boot/
    fi
  fi
}

# copy the configuration to the config partition
# $1 is the config partition device
copy_config () {
  config_partition=$1
  lerror=''
  config_default=$vyatta_sysconfdir/config.boot.default
  tmp_config_default=/tmp/${vyatta_sysconfdir//\//__}

  # create the config directory on the union file system
  mkdir -p $rootfsdir$ofrconfdir

  # create the proper perms on the new config partition
  chgrp vyattacfg $rootfsdir$ofrconfdir
  chmod 775 $rootfsdir$ofrconfdir

  # create our config partition marker
  touch $rootfsdir$ofrconfdir/.vyatta_config

  if [ -d /mnt/config ]; then
    echo "Copying old configurations to config partition."
    cp -pR /mnt/config/* $rootfsdir$ofrconfdir
  else
    # Find the config files and give the user the option to copy config files
    # TODO: this needs cleaned up
    if [ -f $ofrconfdir/config.boot ]; then
	config=$ofrconfdir/config.boot
    fi

    if [ -n "$config" ]; then
      echo "I found the following configuration files"
      for file in $config
      do 
        echo $file
      done

      default=$(echo -e $config | awk '{ print $1 }')

      while [ -z "$configfile" ]
      do
        echo -n "Which one should I copy to $INSTALL_DRIVE? [$default]: "
        configfile=$(get_response "$default" "$config")
      done
      
      echo
      output=$(cp $configfile $rootfsdir$ofrconfdir)
      if [ -n "$output" ]; then
        echo "Error copying file $configfile to config directory.  Exiting..." >> $INSTALL_LOG
        exit 1
      fi
    fi
  fi

  # set the permissions on the new config file
  if [ -f $rootfsdir$ofrconfdir/config.boot ]; then
    chgrp vyattacfg $rootfsdir$ofrconfdir/config.boot
    chmod 775 $rootfsdir$ofrconfdir/config.boot
  fi
}

# copy the saved ssh host key to the new install
copy_sshkeys() {
    if [ -d /mnt/ssh ]; then
	echo "Copying SSH keys."
	cp -p /mnt/ssh/* $rootfsdir/etc/ssh
    fi
}

set_encrypted_password() {
    sed -i \
       -e "/ user $1 {/,/}/s/encrypted-password.*\$/encrypted-password \"$2\"/" $3
}

change_password() {
    local user=$1
    local pwd1="1"
    local pwd2="2"

    until [[ "$pwd1" == "$pwd2" ]]
    do
        read -p "Enter password for user '$user': " -r -s pwd1 <>/dev/tty 2>&0
	echo
        if [[ "$pwd1" == "" ]]; then
          echo "'' is not a valid password"
          continue
        fi	
        read -p "Retype password for user '$user':" -r -s pwd2 <>/dev/tty 2>&0
	echo

	if [ "$pwd1" != "$pwd2" ]
	then 
	  echo "Passwords do not match"
	fi
    done

    # escape any slashes in resulting password
    local epwd=$(mkpasswd -H md5 "$pwd1" | sed 's:/:\\/:g')
    set_encrypted_password $user $epwd  $rootfsdir$ofrconfdir/config.boot
}

# setup grub on the boot sector of a user queried drive
install_grub () {
  # we now use INSTALL_DRIVE to reference the grub boot drive.
  #  that way I can re-use select_drive.  I'm lazy that way.

  if [ ${INSTALL_DRIVE:0:2} != "md" ]; then
    INSTALL_DRIVE=''
  fi

  mkdir -p $rootfsdir/boot/grub
  # Let the user choose the boot sector
  
  while [ -z "$INSTALL_DRIVE" ]
  do
    echo "I need to install the GRUB boot loader."
    echo "I found the following drives on your system:"
    select_drive "Which drive should GRUB modify the boot partition on?"
  done

  echo -n "Setting up grub:  "
  echo "Setting up grub..." >> $INSTALL_LOG

  # Install grub in the boot sector of the primary drive
  progress_indicator start
  grub-install --no-floppy --recheck --root-directory=$rootfsdir /dev/$INSTALL_DRIVE >>$INSTALL_LOG 2>&1
  progress_indicator stop

  # Check if using aufs
  if grep -q aufs /proc/filesystems
  then
      if [ -z "$grub_options" ]
      then
	  grub_options="union=aufs"
      else
	  grub_options="$grub_options union=aufs"
      fi
  fi

  version=`dpkg-query --showformat='${Version}' --show vyatta-version`

  # if union install tell vyatta-grub-setup
  if [ -n "$UNION" ]; then
    grub_args="-u $version"
  else
    grub_args="-v $version"
  fi

  if /opt/vyatta/sbin/vyatta-grub-setup $grub_args "$ROOT_PARTITION" "$grub_options" /mnt/rootfs >>$INSTALL_LOG
  then
    echo "OK"
  else
    echo Grub failed to install!
    exit 1
  fi
}

# ask for user input on the parted and skip setup methods
# $1 is whether or not to run parted
# sets globals INSTALL_DRIVE, ROOT_PARTITION, CONFIG_PARTITION
setup_method_manual() {
  parted=$1

  echo "The VyOS install needs a minimum ${ROOT_MIN}MB root"
  echo "with partiton type 83 (Linux)."
  echo -e "\n\n"

  # if this is parted, let the user create the partitions
  if [ "$INSTALL_METHOD" == "parted" ] || [ "$INSTALL_METHOD" == "p" ]; then
    while [ -z "$INSTALL_DRIVE" ]
    do
      # TODO: right now we only run parted on a single drive
      echo -e "\nI found the following drives on your system:"
      select_drive "Which drive would you like to run parted on?"

    done

    # Unmount the install drive if it is mounted
    unmount "$INSTALL_DRIVE"

    # Run parted and let the user configure
    parted /dev/$INSTALL_DRIVE
  fi

  # Ask for the root partition and make sure it's valid
  while [ -z "$ROOT_PARTITION" ]
  do
    select_partition 500 "Which partition should I install the root on?"
    # Note that PARTITION is defined in select partition
    ROOT_PARTITION=$PARTITION
    unmount "$ROOT_PARTITION"
    vd=$(grep $ROOT_PARTITION /proc/partitions | awk '{ print $4 }')

    if [ -z "$vd" ]; then
      echo
      echo "$ROOT_PARTITION is an invalid partition. Please try again."
      ROOT_PARTITION=""
    fi
  done

  # check for an old config on the partition
  check_config_partition "$ROOT_PARTITION"

  # create the filesystem on the part
  make_filesystem "$ROOT_PARTITION"

  # We need to set the INSTALL_DRIVE if it wasn't set when the user ran parted
  # We assume that we will use the boot sector of the same drive that the 
  # partition is on.
  # TODO: Allow different drives to function as the boot device
  if [ -z "$INSTALL_DRIVE" ]; then
    if [ ${ROOT_PARTITION:0:2} = "md" ]; then
        INSTALL_DRIVE=$ROOT_PARTITION
    else
        INSTALL_DRIVE=$(echo $ROOT_PARTITION | sed 's/[0-9]//g')
    fi
  fi
}

# Walk the user through the auto setup method
# sets globals INSTALL_DRIVE, ROOT_PARTITION, CONFIG_PARTITION
setup_method_auto() {
  while [ -z "$INSTALL_DRIVE" ]
  do
    echo "I found the following drives on your system:"
    select_drive "Install the image on?"

    # check to make sure the drive is large enough to hold the image
    if [ -n "$INSTALL_DRIVE" ]; then 
      lsize=$(get_drive_size "$INSTALL_DRIVE")
      total=$ROOT_MIN
      if [ "$total" -gt "$lsize" ]; then
        echo "Unfortunately, VyOS requires a total of at least $total"MB" to properly install." 
        echo "$INSTALL_DRIVE is below the minimum required capacity and therefore, cannot be used to"
        echo -e "complete the installation.\n"
        echo "If other drives are present"
        echo -e "Please select another drive...\n"

        INSTALL_DRIVE=''
      fi
    fi
  done

  warn_of_dire_consequences

  echo

  # make sure we aren't working on a mounted part
  unmount "$INSTALL_DRIVE"

  # remove any existing partitions on that drive
  delete_partitions "$INSTALL_DRIVE"

  # Enforce minimum partion size requirement.
  ROOT_PARTITION_SIZE=0
  while [ $ROOT_MIN -gt $ROOT_PARTITION_SIZE ]; do
    # Get the size of the drive
    size=$(get_drive_size $INSTALL_DRIVE)

    # If drive is big, leave more space 512K bytes (1024 sectors)
    # this is better for SSD
    if (( $size > 10000 )); then
	ROOT_OFFSET="1024S"
    fi

    echo -n "How big of a root partition should I create? ($ROOT_MIN"MB" - $size"MB") [$size]MB: "
    response=$(get_response "$size")
    # TODO: need to have better error checking on this value
    ROOT_PARTITION_SIZE=$(echo "$response" | sed 's/[^0-9]//g')
    if [ $ROOT_PARTITION_SIZE -lt $ROOT_MIN ] || [ $ROOT_PARTITION_SIZE -gt $size ]; then
      echo "Root partion must be between $ROOT_MIN"MB" and $size"MB""
      echo
      ROOT_PARTITION_SIZE=0
    fi
  done

  echo

  # now take the data and create the partitions
  create_partitions "$INSTALL_DRIVE" "$ROOT_PARTITION_SIZE" "$ROOT_OFFSET" "yes"
  # mark data partition as bootable
  echo "Marking /dev/$INSTALL_DRIVE partition 1 as bootable" >> $INSTALL_LOG
  parted -s /dev/$INSTALL_DRIVE set 1 boot on  >> $INSTALL_LOG 2>&1
  # Must give partition device time to settle
  sleep 5
}

# walk the user through a union setup
# sets globals INSTALL_DRIVE, ROOT_PARTITION, CONFIG_PARTITION
setup_method_union() {
  UNION=1

  echo "A union install requires an image partition of at least 250mbs." 
  echo "If you want to accomodate more than one image on the partition,"
  echo "it should be larger.  Each image is roughly 200mbs.  This "
  echo "partition will be the bootable partition for this machine."
  echo

  # Ask for the image partition and make sure it's valid
  while [ -z "$ROOT_PARTITION" ]
  do
    select_partition 250 "Which partition should I install the images on?"
    # Note that PARTITION is defined in select partition
    ROOT_PARTITION=$PARTITION
    unmount "$ROOT_PARTITION"
    vd=$(grep $ROOT_PARTITION /proc/partitions | awk '{ print $4 }')

    if [ -z "$vd" ]; then
      echo
      echo "$ROOT_PARTITION is an invalid partition. Please try again."
      ROOT_PARTITION=""
    fi
  done
 
  echo Creating filesystem on $ROOT_PARTITION 
  make_filesystem $ROOT_PARTITION

  echo
  echo "An optional writable persistent root partition may also"
  echo "be created.  This partition will allow you to store "
  echo "files between reboots and upgrade packages."  
  echo 
  echo -n "Would you like to create a persistent root partition? (Yes/No) [Yes]: "
  response=$(get_response "Yes" "Yes No Y N")
  if [ "$response" == "yes" ] || [ "$response" == "y" ]; then
    echo "The persistent root partition should be a minimum of 50mbs"
    echo "for log files.  If you plan on adding any other software or"
    echo "upgrading it, the root partition should be large enough to"
    echo "accomodate those packages"

    # Ask for the union partition and make sure it's valid
    while [ -z "$UNION_PARTITION" ]
    do
      select_partition 50 "Which partition should I install the binary images on?" "$ROOT_PARTITION"
      # Note that PARTITION is defined in select partition
      UNION_PARTITION=$PARTITION
      unmount "$UNION_PARTITION"
      vd=$(grep $UNION_PARTITION /proc/partitions | awk '{ print $4 }')

      if [ -z "$vd" ]; then
        echo
        echo "$UNION_PARTITION is an invalid partition. Please try again."
        UNION_PARTITION=""
      fi
    done

    echo Creating filesystems on $ROOT_PARTITION 
    make_filesystem $UNION_PARTITION

    echo Labeling $UNION_PARTITION 
    e2label /dev/$UNION_PARTITION live-rw
  fi
}

unmount () {
  # grab the list of mounted drives
  # make sure to reverse sort so as to unmount up the tree
  mounted=$(mount | grep "$1" | cut -f3 -d' ' | sort -r)
  if [ -n "$mounted" ]; then
    echo    "I need to unmount: "
    echo    "$mounted"

    response=''
    while [ -z "$response" ]
    do 
      echo -n "Continue (Yes/No) [No]: "
      response=$(get_response "No" "Yes No Y N")
      if [ "$response" == "no" ] || [ "$response" == "n" ]; then
        echo -e "Ok then.  Need to unmount to continue.\nExiting..."
        exit 1
      fi
    done
 
    for parts in "$mounted"
    do
      echo "umount $parts" >> $INSTALL_LOG
      output=$(umount $parts)
      status=$?
      if [ "$status" != 0 ]; then
        echo -e "Exiting: error unmounting $parts.\nPlease see $INSTALL_LOG for more details."
        echo -e "Exiting: error unmounting $parts.\numount $parts\n$output" >> $INSTALL_LOG
        exit 1
      fi
    done
  fi
}

setup_xen_partition_images () {
  if [ -d "$rootfsdir/var/xen/" ]; then
    echo Setting up Xen virtual machine images
    compressed_images=$(ls $rootfsdir/var/xen/*.img.gz 2> /dev/null)
    if [ -n "$compressed_images" ]; then
      for cmp_img in $compressed_images; do
        # uncompress the image
        uncmp_img=$(echo $cmp_img | sed s'/.gz$//') 
        if [ ! -f "$uncmp_img" ]; then
          echo decompressing $cmp_img
          gzip -dc $cmp_img > $uncmp_img
        fi
      done
    fi
    echo
  fi
}

setup_xen_extras () {
    echo "Setting up config files for Xen..."
    # Set up /boot/grub/menu.lst for use by pygrub
    grubfile=$rootfsdir/boot/grub/menu.lst
    echo "timeout 5" >> $grubfile
    echo "" >> $grubfile
    echo "title    vyos-virt" >> $grubfile
    echo "root     (hd0,0)" >> $grubfile
    echo "kernel   /boot/vmlinuz root=/dev/xvda1 ro console=hvc0" >> $grubfile
    echo "initrd   /boot/initrd.img" >> $grubfile

    # Add /proc/xen entry to fstab
    echo "xenfs   /proc/xen       xenfs   defaults        0 0" >> $rootfsdir/etc/fstab

    # Comment out serial port entry and add Xen console entry to inittab.
    inittab=$rootfsdir/etc/inittab
    sed -i -e 's/^T0/#T0/' $inittab
    echo "" >> $inittab
    echo "h0:12345:respawn:/sbin/getty 38400 hvc0" >> $inittab
}

check_for_xen_extras () {
    prod=`/usr/sbin/dmidecode -s system-product-name`
    if [ "$MANUF" = "Xen" -a "$prod" = "HVM domU" ]; then
	echo "You are installing to a $MANUF $prod virtual machine."
	echo "Would you like to set up config files to prepare for the"
	echo -n "conversion to PV domU? [No]: "
	response=$(get_response "No" "Yes No Y N")
	if [ "$response" == "yes" ] || [ "$response" == "y" ]; then
	    setup_xen_extras
	fi
    fi
}

progress_indicator () {
  case "$1" in
    start) $vyatta_bindir/progress-indicator $SPID &
             ;;
    *)
	     if ! rm /tmp/pi.$SPID 2>/dev/null
	     then
		sleep 1
		rm /tmp/pi.$SPID 2>/dev/null
	     fi

             sleep 1
	     echo -n -e "\b"
             ;;
  esac
}

#####  Main
##
# turn off any mounted swap files
turnoffswap

# Print welcome and instructions.
echo "Welcome to the VyOS install program.  This script"
echo "will walk you through the process of installing the"
echo "VyOS image to a local hard drive."
echo

response=''
while [ -z "$response" ]
do
  echo -n "Would you like to continue? (Yes/No) [Yes]: "
  response=$(get_response "Yes" "Yes No Y N")
  if [ "$response" == "no" ] || [ "$response" == "n" ]; then
    echo "Ok then.  Exiting..."
    exit 1
  fi
done

# some drives don't show up in /proc/partitions so we need to bootstrap them
echo -n "Probing drives:  "
progress_indicator start
probe_drives
progress_indicator stop
echo "OK"

INSTALL_METHOD=''
check_for_old_raid
if [ -z "$INSTALL_METHOD" ]; then
    check_for_new_raid
fi

if [ -z "$INSTALL_METHOD" ]; then
    echo "The VyOS image will require a minimum ${ROOT_MIN}MB root."
    echo "Would you like me to try to partition a drive automatically"
    echo "or would you rather partition it manually with parted?  If"
    echo "you have already setup your partitions, you may skip this step."
    echo

    while [ -z "$INSTALL_METHOD" ]
    do
	echo -n "Partition (Auto/Union/Parted/Skip) [Auto]: "
	INSTALL_METHOD=$(get_response "Auto" "Auto Parted Skip Union A P S U")
    done

    echo
fi
  
# Unless doing union install, must be from live cd
if [ $INSTALL_METHOD != "union" -a $INSTALL_METHOD != "u" ] &&
   [ -w /lib/live/mount/medium ]
then
    echo "install-system can only be run from livecd"
    echo "(except if doing union install)"
    exit 1
fi

# TODO: Note installs assume an LBA BIOS.  So no boot partition currently.
# also note that we are not creating a swap partition right now.
if [ "$INSTALL_METHOD" == "parted" ] || [ "$INSTALL_METHOD" == "p" ]; then
  setup_method_manual "parted"
elif [ "$INSTALL_METHOD" == "skip" ] || [ "$INSTALL_METHOD" == "s" ]; then
  setup_method_manual "skip" 
elif [ "$INSTALL_METHOD" == "auto" ] || [ "$INSTALL_METHOD" == "a" ]; then
  setup_method_auto
elif [ "$INSTALL_METHOD" == "union" ] || [ "$INSTALL_METHOD" == "u" ]; then
  echo "A union install requires an image partition of at least 250mbs."
  echo "If you want to accomodate more than one image on the partition,"
  echo "it should be larger.  Each image is roughly 200mbs.  This "
  echo "partition will be the bootable partition for this machine."
  echo

  UNION=1
  setup_method_auto
elif [ "$INSTALL_METHOD" == "vyatta" ]; then
  echo "Automated install..."
  echo "unmounting $INSTALL_DRIVE"
  unmount "$INSTALL_DRIVE"
  echo "deleting partitions on $INSTALL_DRIVE"
  delete_partitions "$INSTALL_DRIVE"
  echo "creating config partition"
  create_partitions "$INSTALL_DRIVE" "$ROOT_PARTITION_SIZE" "$ROOT_OFFSET" "yes"
  # mark data partition as bootable
  echo "Marking /dev/$INSTALL_DRIVE partition 1 as bootable" >> $INSTALL_LOG
  parted -s /dev/$INSTALL_DRIVE set 1 boot on >> $INSTALL_LOG 2>&1
  # Must give partition device time to settle
  sleep 5
fi

# Install the root filesystem
install_root_filesystem "$ROOT_PARTITION"

# Copy the config files
copy_config "$CONFIG_PARTITION"

# Modify config to match system
# Assume user wants to keep password from old config
if [ ! -d /mnt/config ]; then
   # Disable root login
   set_encrypted_password root "*" $rootfsdir$ofrconfdir/config.boot

   echo "Enter password for administrator account"
   change_password vyos
fi

# restore ssh host keys
copy_sshkeys

# check for xen part images in /var/xen
setup_xen_partition_images

# Install grub
install_grub

check_for_xen_extras

if [ -z "$UNION" ]; then
  # Fix up PAM configuration for login so that invalid users are prompted
  # for password
  sed -i 's/requisite[ \t][ \t]*pam_securetty.so/required pam_securetty.so/' $rootfsdir/etc/pam.d/login
fi

#
# Only start the mdadm daemon if we have the root filesystem running
# on a RAID set.  Since this script is the only way that the root filesystem
# ever gets set up, we can do this configuration here.
#
MDADM_CONFIG_FILE=$rootfsdir/etc/default/mdadm
if [ -e $MDADM_CONFIG_FILE ]; then
    if [ ${INSTALL_DRIVE:0:2} = "md" ]; then
	sed -i -e 's/^START_DAEMON.*$/START_DAEMON=true/'  \
	       -e 's/^AUTOSTART=.*$/AUTOSTART=true/' $MDADM_CONFIG_FILE
    else
	sed -i -e 's/^START_DAEMON.*$/START_DAEMON=false/' \
	       -e 's/^AUTOSTART=.*$/AUTOSTART=false/' $MDADM_CONFIG_FILE
    fi
fi

postinst_root=$rootfsdir
writable_root=''
if [ -n "$UNION" ]; then
    # set up root for postinst
    postinst_root=/mnt/postinst_root
    writable_root=$rootfsdir
    version=`dpkg-query --showformat='${Version}' --show vyatta-version`
    rw_dir=$rootfsdir/boot/$version/live-rw

    mkdir -p $postinst_root /mnt/squashfs
    mount -o loop,ro -t squashfs \
	$rootfsdir/boot/$version/$version.squashfs /mnt/squashfs
    mount -t unionfs -o noatime,dirs=$rw_dir=rw:/mnt/squashfs=ro unionfs \
	$postinst_root

    # handle start-up config file
    mkdir -p $postinst_root/$ofrconfdir
    if [ -f $rootfsdir/$ofrconfdir/config.boot ]; then
	cp -p $rootfsdir/$ofrconfdir/* $postinst_root/$ofrconfdir/
    fi
 
    # set up /var/run
    pi_fstab=$postinst_root/etc/fstab
    if ! grep -q 'tmpfs /var/run ' $pi_fstab >&/dev/null; then
	# replace the fstab. the default one has header that will cause
	# it to be wiped out on live boot.
	echo 'tmpfs /var/run tmpfs nosuid,nodev 0 0' >$pi_fstab
    fi
fi

# postinst hook
if [ -e /opt/vyatta/etc/install-system/postinst ]; then
  echo "running post-install script"
  /opt/vyatta/etc/install-system/postinst $postinst_root $writable_root \
    >>$INSTALL_LOG
fi

if [ -n "$UNION" ]; then
    umount $postinst_root
    umount /mnt/squashfs
fi

cp $INSTALL_LOG $rootfsdir/install.log

umount $rootfsdir

echo "Done!"
echo "Done!" >> $INSTALL_LOG

exit 0
